/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PerilousWritingPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/perilous/perilous.ts
var import_state = require("@codemirror/state");

// src/constants.ts
var LOG_LEVEL = false;

// src/utilities.ts
var import_obsidian = require("obsidian");
function parseInteger(s) {
  const n = Number.parseInt(s);
  if (!Number.isNaN(n)) {
    return n;
  } else {
    return void 0;
  }
}
function parseFloating(s) {
  const n = Number.parseFloat(s);
  if (!Number.isNaN(n)) {
    return n;
  } else {
    return void 0;
  }
}
function roundFloat(n, dp) {
  return Math.round(n * 10 ** dp) / 10 ** dp;
}
function log(event) {
  if (LOG_LEVEL === false) {
    return;
  }
  const now = new Date();
  console.log(
    `[PW][${now.getMinutes()}:${now.getSeconds()}:${now.getMilliseconds()}] ${event}`
  );
}
var CustomSessionModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Begin custom session" });
    new import_obsidian.Setting(contentEl).setName("Length (minutes)").addText(
      (text) => text.onChange((input) => {
        this.input = input;
      })
    );
    new import_obsidian.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Submit").setCta().onClick(() => {
        const sessionLength = parseFloating(this.input);
        if (sessionLength === void 0 || sessionLength <= 0) {
          new import_obsidian.Notice(`Error: Please enter a valid, positive number.`);
          return;
        }
        this.onSubmit(sessionLength);
        this.close();
      })
    );
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// src/perilous/dom.ts
var PROGRESS_BAR_BACKGROUND_ID = "perilous-writing-progress-bar-background";
var PROGRESS_BAR_WRAPPER_ID = "perilous-writing-progress-bar-wrapper";
var PROGRESS_BAR_BAR_ID = "perilous-writing-progress-bar-bar";
function addProgressBar(view, sessionLength) {
  const tabContainer = view.leaf.parent.tabsContainerEl;
  tabContainer.style.position = "relative";
  tabContainer.appendChild(ProgressBarBackground());
  tabContainer.appendChild(ProgressBarBar(sessionLength));
}
function removeProgressBar() {
  const progressBarBackground = activeDocument.getElementById(
    PROGRESS_BAR_BACKGROUND_ID
  );
  const progressBarBar = activeDocument.getElementById(PROGRESS_BAR_WRAPPER_ID);
  progressBarBackground == null ? void 0 : progressBarBackground.remove();
  progressBarBar == null ? void 0 : progressBarBar.remove();
}
function setProgressPercent(percent) {
  const element = activeDocument.getElementById(PROGRESS_BAR_WRAPPER_ID);
  if (element !== null) {
    element.style.width = `${percent}%`;
  }
}
function completeProgressBar() {
  const element = activeDocument.getElementById(PROGRESS_BAR_WRAPPER_ID);
  if (element !== null) {
    element.style.transition = "none";
  }
}
function setProgressBarState(state, warningPercent = 0) {
  const element = activeDocument.getElementById(PROGRESS_BAR_BAR_ID);
  if (element === null) {
    return;
  }
  const color = {
    default: "purple",
    success: "green",
    failure: "red",
    warning: "orange"
  }[state];
  if (state === "warning") {
    element.style.background = interpolateWarningColor(warningPercent);
  } else {
    element.style.background = `var(--color-${color})`;
  }
}
function interpolateWarningColor(warningPercent) {
  if (0 <= warningPercent && warningPercent < 40) {
    return "hsl(30deg 100% 46%)";
  } else if (40 <= warningPercent && warningPercent < 60) {
    return "hsl(18deg 86% 54%)";
  } else if (60 <= warningPercent && warningPercent < 70) {
    return "hsl(5deg 84% 58%)";
  } else if (70 <= warningPercent && warningPercent < 80) {
    return "hsl(353deg 81% 5j%)";
  } else {
    return "var(--color-red)";
  }
}
function ProgressBarBackground() {
  const wrapper = activeDocument.createElement("div");
  wrapper.id = PROGRESS_BAR_BACKGROUND_ID;
  return wrapper;
}
function ProgressBarBar(sessionLength) {
  const wrapper = activeDocument.createElement("div");
  wrapper.id = PROGRESS_BAR_WRAPPER_ID;
  wrapper.style.transition = `width ${sessionLength}ms linear`;
  const inner = activeDocument.createElement("div");
  inner.id = PROGRESS_BAR_BAR_ID;
  wrapper.appendChild(inner);
  return wrapper;
}

// src/perilous/scheduler.ts
var Scheduler = class {
  constructor(sessionLength, hooks) {
    // Core parameters
    this.timeoutInterval = 5e3;
    this.warningInterval = 2e3;
    this.tickLength = 200;
    // Scheduler state
    this.schedulerState = "initialised";
    // Internals
    this.elapsedTime = 0;
    this.sinceLastEvent = 0;
    this.startedScheduler = false;
    this.intervalId = void 0;
    this.sessionLength = sessionLength;
    this.hooks = hooks;
    this.eventCallback = this.onEvent.bind(this);
  }
  /**
   * Register the primary event stream handler.
   */
  initialise(registerEventGenerator) {
    this.hooks.onInitialisation();
    registerEventGenerator(this.eventCallback);
  }
  tick() {
    const {
      sessionLength,
      timeoutInterval,
      warningInterval,
      tickLength,
      elapsedTime,
      sinceLastEvent
    } = this;
    if (elapsedTime >= sessionLength) {
      this.succeed();
      return;
    } else if (sinceLastEvent >= timeoutInterval) {
      this.fail();
      return;
    }
    if (warningInterval <= sinceLastEvent && sinceLastEvent < timeoutInterval) {
      this.warning();
    }
    this.sinceLastEvent += tickLength;
    this.elapsedTime += tickLength;
  }
  onEvent() {
    if (this.startedScheduler === false) {
      this.intervalId = window.setInterval(
        this.tick.bind(this),
        this.tickLength
      );
      this.startedScheduler = true;
      this.schedulerState = "running";
      this.hooks.onStart(this.intervalId);
    } else {
      this.sinceLastEvent = 0;
      this.hooks.onEvent();
    }
  }
  succeed() {
    this.schedulerState = "success";
    this.hooks.onSuccess();
    this.teardown();
  }
  warning() {
    const { warningInterval, sinceLastEvent, timeoutInterval } = this;
    this.hooks.onWarning(
      (sinceLastEvent - warningInterval) / (timeoutInterval - warningInterval) * 100
    );
  }
  fail() {
    this.schedulerState = "failure";
    this.hooks.onFailure();
    this.teardown();
  }
  teardown() {
    this.hooks.onTeardown();
    clearInterval(this.intervalId);
  }
};
function canStartScheduler(scheduler) {
  return scheduler === void 0 || scheduler.schedulerState !== "initialised" && scheduler.schedulerState !== "running";
}

// src/perilous/perilous.ts
var MILLISECONDS_PER_MINUTE = 6e4;
function startSession(editor, view, plugin, sessionType, length) {
  let sessionLength = 0;
  if (sessionType === "custom") {
    sessionLength = length;
  } else if (sessionType === "short") {
    sessionLength = plugin.settings.shortSessionLength;
  } else {
    sessionLength = plugin.settings.longSessionLength;
  }
  sessionLength *= MILLISECONDS_PER_MINUTE;
  log(`Session length: ${sessionLength / MILLISECONDS_PER_MINUTE}m`);
  const cmExtensions = [];
  const [initialContent, initialCursor] = getSnapshot(editor);
  removeProgressBar();
  addProgressBar(view, sessionLength);
  const hooks = {
    onInitialisation: () => {
      log("Session requested; waiting for first event");
    },
    onStart: (intervalId) => {
      setProgressPercent(100);
      plugin.registerInterval(intervalId);
      log("Scheduler started");
    },
    onEvent: () => {
      setProgressBarState("default");
      log("Event");
    },
    onWarning: (percentCompleted) => {
      setProgressBarState("warning", percentCompleted);
      log(`Warning; ${Math.round(percentCompleted)}`);
    },
    onSuccess: () => {
      completeProgressBar();
      setProgressBarState("success");
      log("Session completed successfully");
    },
    onFailure: () => {
      completeProgressBar();
      setProgressBarState("failure");
      replaceSnapshot(editor, view, initialContent, initialCursor);
      log("Session failed; replaced contents with prior revision");
    },
    onTeardown: () => {
      cmExtensions.pop();
      plugin.app.workspace.updateOptions();
      log("Removed: CodeMirror hook; &c.");
    }
  };
  const scheduler = new Scheduler(sessionLength, hooks);
  scheduler.initialise((eventCallback) => {
    const onInputKeypress = import_state.StateField.define({
      create: () => null,
      update: (_, transaction) => {
        if (!transaction.docChanged) {
          return null;
        }
        if (transaction.isUserEvent("input")) {
          eventCallback();
        }
        return null;
      }
    });
    cmExtensions.push(onInputKeypress);
    plugin.registerEditorExtension(cmExtensions);
    log("Registered CodeMirror hook");
  });
  return scheduler;
}
function abortSession() {
  removeProgressBar();
}
function getSnapshot(editor) {
  const doc = editor.getDoc();
  return [doc.getValue(), doc.getCursor()];
}
function replaceSnapshot(editor, view, value, cursor) {
  view.clear();
  const doc = editor.getDoc();
  doc.setValue(value);
  doc.setCursor(cursor);
}

// src/settings.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  shortSessionLength: 5,
  longSessionLength: 10
};
var PerilousWritingSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", {
      text: "Perilous Writing: Settings"
    });
    new import_obsidian2.Setting(containerEl).setName("Short session length (minutes)").addText(
      (text) => text.setPlaceholder("Enter length in minutes").setValue(this.plugin.settings.shortSessionLength.toString()).onChange(async (value) => {
        const length = parseInteger(value);
        if (length !== void 0 && length > 0) {
          this.plugin.settings.shortSessionLength = length;
          await this.plugin.saveSettings();
        } else if (value === "") {
          this.plugin.settings.shortSessionLength = DEFAULT_SETTINGS.shortSessionLength;
          await this.plugin.saveSettings();
        } else {
          new import_obsidian2.Notice(
            `Error: value '${value}' is not a valid session length.`
          );
        }
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Long session length (minutes)").addText(
      (text) => text.setPlaceholder("Enter length in minutes").setValue(this.plugin.settings.longSessionLength.toString()).onChange(async (value) => {
        const length = parseInteger(value);
        if (length !== void 0 && length > 0) {
          this.plugin.settings.longSessionLength = length;
          await this.plugin.saveSettings();
        } else if (value === "") {
          this.plugin.settings.longSessionLength = DEFAULT_SETTINGS.longSessionLength;
          await this.plugin.saveSettings();
        } else {
          new import_obsidian2.Notice(
            `Error: value '${value}' is not a valid session length.`
          );
        }
      })
    );
  }
};

// src/main.ts
var PerilousWritingPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new PerilousWritingSettingTab(this.app, this));
    this.addCommand({
      id: "short-session",
      name: `Begin short session`,
      editorCallback: (editor, view) => {
        if (canStartScheduler(this.scheduler)) {
          this.scheduler = startSession(editor, view, this, "short");
        } else {
          new import_obsidian3.Notice("A session is already in progress.");
        }
      }
    });
    this.addCommand({
      id: "long-session",
      name: `Begin long session`,
      editorCallback: (editor, view) => {
        if (canStartScheduler(this.scheduler)) {
          this.scheduler = startSession(editor, view, this, "long");
        } else {
          new import_obsidian3.Notice("A session is already in progress.");
        }
      }
    });
    this.addCommand({
      id: "custom-session",
      name: `Begin custom session`,
      editorCallback: (editor, view) => {
        if (!canStartScheduler(this.scheduler)) {
          new import_obsidian3.Notice("A session is already in progress.");
          return;
        }
        new CustomSessionModal(this.app, (sessionLength) => {
          this.scheduler = startSession(
            editor,
            view,
            this,
            "custom",
            roundFloat(sessionLength, 1)
          );
        }).open();
      }
    });
    this.addCommand({
      id: "clear-session",
      name: "Clear session",
      checkCallback: (checking) => {
        var _a;
        if (checking) {
          if (this.scheduler && ["success", "failure", "initialised"].includes(
            this.scheduler.schedulerState
          )) {
            return true;
          } else {
            return false;
          }
        }
        (_a = this.scheduler) == null ? void 0 : _a.teardown();
        this.scheduler = void 0;
        removeProgressBar();
      }
    });
    log("Loaded plugin");
  }
  onunload() {
    if (this.scheduler !== void 0) {
      this.scheduler.teardown();
      abortSession();
    }
    log("Unloaded plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
